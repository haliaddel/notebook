

#### mysql架构

![](C:\Users\武伟红\AppData\Roaming\marktext\images\2022-03-27-21-20-15-image.png)

1. 第一层：对客户端的连接处理、授权认证、安全等，每个客户端都会在服务端拥有一个线程，每个连接发起的查询都在对应的单独线程中执行。

2. 第二层：MYSQL核心服务层，包括查询解析、分析、查询缓存、内置函数、存储过程、触发器、视图等。

3. 第三层包含存储引擎：存储引擎负责mysql中数据的存储和提取。



#### 并发控制

1. 读写锁

  处理并发控制可以用两种类型的锁组成的锁系统解决问题。两种类型分别是共享锁和排他锁，也叫读写和写锁。读锁是共享的，多个客户在同一时刻允许读取同一资源，写锁是排他的，写锁会阻塞其他的读锁和写锁。

2. 锁粒度

   mysql每种存储引擎都可以 是心啊自己的锁策略和锁粒度。锁策略是指在锁的开销和数据的安全性之间寻求平衡。



#### 表锁

表锁是mysql中最基本的锁策略，也是开销最小的策略。



#### 行级锁

可以最大程度支持并发 处理，同时也带来最大的锁开销。行级锁只在存储引擎层实现，mysql服务器层没有实现。



#### 优化数据类型

1. 更小的通常更好：更小的数据类型通常更快，因为占用更少的磁盘、内存和CPU缓存，处理时需要的CPU周期也更少。

2. 简单就好：简单数据类型通常需要更少的PCU周期。如，整型比字符串操作代价更低。有两个例子：一个是应该用MySQL内建的类型而不是字符串存储日期和时间，另一个是应该用整型存储IP地址。

3. 尽量避免NULL：查询中若包含可为NULL的列，对myql更难优化，因为可为NULL的列使得索引、索引统计和值比较都更复杂。可为NULL的列会使用更多存储空间，在mysql里也需要特殊处理。通常将NULL的列改为NOT NULL带来的性能提升较小，所以没必要改掉这种情况。但是，如果在列上建索引，就要进来避免设计成可为NULL的列。



#### 索引基础

所以可以包含一个或多个列。如果索引包含多个列，则列的顺序很重要，因为mysql只能高效使用索引的最左前缀列。创建一个包含两个列的索引，和创建两个只包含一列的索引大不相同。

1. 索引的类型
   
   mysql支持的索引类型：
   
   + B-Tree索引：使用B-Tree数据结构存储数据。
